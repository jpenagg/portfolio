<!DOCTYPE html><html lang="en"> <head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1"><title> · jpena.dev</title><link rel="preconnect" href="https://fonts.googleapis.com"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@400;600&display=swap" rel="stylesheet"><link rel="stylesheet" href="/_astro/site-reliability-engineering.D2UypIes.css"></head> <body> <header class="site-header"> <div class="nav-bar"> <nav class="nav"> <a class="nav-home" href="/">Home</a> <a href="/posts/">Posts</a> <a href="/files/jpena_cv.pdf">Resume</a> <a href="/about/">About</a> </nav> <button class="theme-toggle" type="button" data-theme-toggle aria-pressed="false" aria-label="Toggle theme"> <svg data-icon="sun" viewBox="0 0 24 24" aria-hidden="true"> <path d="M12 4.5a1 1 0 0 1 1 1V7a1 1 0 1 1-2 0V5.5a1 1 0 0 1 1-1zm0 10a2.5 2.5 0 1 0 0-5 2.5 2.5 0 0 0 0 5zm7.5-3.5a1 1 0 0 1-1 1H17a1 1 0 1 1 0-2h1.5a1 1 0 0 1 1 1zM8 12a1 1 0 0 1-1 1H5.5a1 1 0 1 1 0-2H7a1 1 0 0 1 1 1zm8.95-5.45a1 1 0 0 1 0 1.41l-1.06 1.06a1 1 0 1 1-1.41-1.41l1.06-1.06a1 1 0 0 1 1.41 0zM9.52 15.98a1 1 0 0 1 0 1.41l-1.06 1.06a1 1 0 1 1-1.41-1.41l1.06-1.06a1 1 0 0 1 1.41 0zM19.01 15.98a1 1 0 0 1 0 1.41l-1.06 1.06a1 1 0 1 1-1.41-1.41l1.06-1.06a1 1 0 0 1 1.41 0zM9.52 6.57a1 1 0 0 1 0 1.41L8.46 9.04A1 1 0 1 1 7.05 7.63l1.06-1.06a1 1 0 0 1 1.41 0z"></path> </svg> <svg data-icon="moon" viewBox="0 0 24 24" aria-hidden="true"> <path d="M21 14.5A8.5 8.5 0 0 1 9.5 3a1 1 0 0 0-.92 1.39A7.5 7.5 0 0 0 20.6 15.92 1 1 0 0 0 21 14.5z"></path> </svg> </button> </div> </header> <main class="wrap"> <article class="post"> <h1 class="page-title"></h1> <div class="post-body"> <p><img src="/static/prisma-main.png" alt="aws_prisma_terraform"></p>
<p>A recent project that I worked on introduced Prisma to our stack, an ORM-like layer that does the heavy lifting in your GraphQL server. Rather than diving deep into what Prisma is and how it operates, this post will guide you through using Terraform to automate &#x26; deploy the entire stack — The Prisma server &#x26; the AWS resources needed to support it.</p>
<p>If you prefer using CloudFormation for IaaC, there’s already an awesome <a href="https://www.prisma.io/tutorials/deploy-prisma-to-aws-fargate-ct14">tutorial</a> for you.</p>
<h2 id="what-is-prisma">What is Prisma?</h2>
<p><img src="/static/prisma-diagram.png" alt="prisma"></p>
<p>Prisma replaces traditional ORMs and simplifies database workflows. It is used to build GraphQL, REST, gRPC APIs and more. It supports PostgreSQL, MySQL and MongoDB. Essentially, it is a standalone infrastructure component that sits on top of your database, and ultimately enables you to talk to your database(s) through a simple and modern API ensuring highly performant and secure database access. We will be using PostgreSQL for this exercise.</p>
<ul>
<li>The AWS Stack</li>
<li>VPC</li>
<li>ECS (Fargate)</li>
<li>RDS (PostreSQL)</li>
<li>ALB</li>
<li>CloudWatch (Logs)</li>
<li>Security Groups</li>
</ul>
<h2 id="getting-started">Getting Started</h2>
<p>Here’s a few things you’ll need before we start building our modules:</p>
<ul>
<li>Terraform version <code>0.12</code></li>
<li>ACM public certificate</li>
</ul>
<p>If you haven’t upgraded Terraform to version 0.12 yet, you should, and take advantage of all the new features.
The final product of this post is <strong>NOT</strong> meant to be production ready. Meaning, there are better ways to handle secrets &#x26; not having them in plain text. There might also be additional IAM roles, policies and security groups that you need to create to help lock down your infrastructure. And you should also structure your Terraform projects in such a way that your modules are reusable across all of your environments, which ultimately keep your Terraform code DRY. There’s a section below that touches on this subject. You should also not name your database password password but that goes without saying :)</p>
<h2 id="remote-state">Remote State</h2>
<p>The first thing you should probably create is your state file. In this tutorial we will be using a remote state file stored on S3, with state locking provided by DynamoDB.</p>
<h2 id="provider">Provider</h2>
<p>You’ll also need the AWS provider to interact with the many resources supported by AWS. Make sure to change your profile as needed.</p>
<h2 id="vpc">VPC</h2>
<p>Next, we create our VPC, which will consist of 2 public subnets, 2 private subnets, an internet gateway, a NAT gateway, &#x26; route tables. I’m launching this stack into us-west-1 so adjust accordingly.</p>
<h2 id="ecs">ECS</h2>
<p>Here is the Prisma ECS task definition template in JSON format. Note that the PRISMA_CONFIG environment variable contains key value pairs of strings which Prisma parses as YAML. For this we can interpolate any values of our choosing using Terraform’s template_file data source (See ECS module).</p>
<p>Next, we create our ECS cluster. ECS consists of a cluster, a service, a task and a task definition. You can think of a cluster as a logical grouping of containers. A service is essentially the scheduler, and is in charge of making sure that the specified number of tasks is running at all times. The task is the running container instance. The task definition is like a Docker Compose file, and contains the container configurations. More on ECS here.
For now we are specifying the desired count as 1, but you can easily change this to 2 (or more) for higher availability. You’ll also notice a CloudWatch log group is being created here, which Prisma will output logs to.</p>
<h2 id="alb">ALB</h2>
<p>Next, we create our ALB. The load balancer distributes incoming application traffic across multiple targets, which in this case will be the running ECS tasks.</p>
<h2 id="rds">RDS</h2>
<p>Next, we create our RDS instance. We are using PostgreSQL as our Prisma database connector.</p>
<h2 id="variables">Variables</h2>
<p>Next, we can define our variables. It’s nice to pretty up your variables.tf by adding descriptions and default values if applicable.</p>
<p>And lastly, we can create our input variables file. I will be naming it input.tfvars. Make sure to update prisma_server_acm with the ARN of your ACM certificate. Depending on how the rest your infrastructure is set up, you can also use a terraform_remote_state data source or perhaps an output value to retrieve the ARN of your ACM if it’s handled by Terraform. For now we can just hardcode it.</p>
<h2 id="plan--apply">Plan &#x26; Apply</h2>
<p>Once this is all set up, the magic begins…</p>
<p>Initialize your working directory if you haven’t already with:</p>
<p><code>terraform init</code></p>
<p>Next, create your execution plan:</p>
<p><code>terraform plan -var-file=input.tfvars</code></p>
<p>This should yield:</p>
<p><code>Plan: 32 to add, 0 to change, 0 to destroy.</code></p>
<p>Review the plan, and if all looks good, apply the changes:</p>
<p><code>terraform apply -var-file=input.tfvars -auto-approve</code></p>
<p>Time to go grab a coffee or a snack. This might take a while. But rest assured when you get back, and by the grace of the Terraform gods, all of your AWS infrastructure and Prisma should have been automagically deployed! Woo!</p>
<p><code>Apply complete! Resources: 32 added, 0 changed, 0 destroyed.</code></p>
<p>Navigate to your ALB endpoint and you should see your Prisma server up &#x26; running!</p>
<p><img src="/static/prisma-ui.png" alt="aws_prisma_terraform"></p>
<h2 id="reusable-modules">Reusable Modules</h2>
<p>If you have multiple environments that you plan to deploy to, you can structure your repo in such a way that your Terraform modules are reusable across dev, stage, and prod. You can even put your modules into a separate repo entirely.
Your project structure should end up looking something like this:</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="plaintext"><code><span class="line"><span>stage</span></span>
<span class="line"><span>  └ tasks</span></span>
<span class="line"><span>     └ prisma.json</span></span>
<span class="line"><span>  └ main.tf</span></span>
<span class="line"><span>  └ input.tfvars</span></span>
<span class="line"><span>  └ secrets.tfvars</span></span>
<span class="line"><span>prod</span></span>
<span class="line"><span>  └ tasks</span></span>
<span class="line"><span>     └ prisma.json</span></span>
<span class="line"><span>  └ main.tf</span></span>
<span class="line"><span>  └ input.tfvars</span></span>
<span class="line"><span>  └ secrets.tfvars</span></span>
<span class="line"><span>modules </span></span>
<span class="line"><span>  └ prisma-cluster   </span></span>
<span class="line"><span>     └ alb.tf</span></span>
<span class="line"><span>     └ ecs.tf</span></span>
<span class="line"><span>     └ variables.tf</span></span>
<span class="line"><span>  └ prisma-rds</span></span>
<span class="line"><span>     └ rds.tf</span></span>
<span class="line"><span>     └ variables.tf</span></span>
<span class="line"><span></span></span></code></pre>
<p>And your main.tf should now look something like this:</p>
<h2 id="conclusion">Conclusion</h2>
<p>The purpose of this post (and it’s my first one!) is meant to be a learning exercise, hopefully for you, but also for me. I would really appreciate any feedback that can help me as well as others going forward. That being said, my experience with Terraform has been nothing short of amazing and I hope it is for you too!</p> </div> </article> </main> <script>
      const root = document.documentElement;
      const toggle = document.querySelector("[data-theme-toggle]");
      const sun = toggle?.querySelector('[data-icon="sun"]');
      const moon = toggle?.querySelector('[data-icon="moon"]');
      const saved = localStorage.getItem("theme");
      const initial = saved || "dark";
      root.dataset.theme = initial;
      if (toggle) {
        if (sun && moon) {
          sun.style.display = initial === "dark" ? "none" : "block";
          moon.style.display = initial === "dark" ? "block" : "none";
        }
        toggle.setAttribute("aria-pressed", initial === "dark");
        toggle.addEventListener("click", () => {
          const next = root.dataset.theme === "dark" ? "light" : "dark";
          root.dataset.theme = next;
          localStorage.setItem("theme", next);
          if (sun && moon) {
            sun.style.display = next === "dark" ? "none" : "block";
            moon.style.display = next === "dark" ? "block" : "none";
          }
          toggle.setAttribute("aria-pressed", next === "dark");
        });
      }
    </script> </body> </html>